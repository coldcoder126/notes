# 必要知识

**AVL树：**平衡二叉树

**B树（B- 树）：**平衡多路查找树

**B+树：**基于B- 树的一种变体；子节点保存有父节点的数据；非叶子节点不保存关键字记录的指针，只进行数据索引。

MySQL索引的数据结构是B+树。



**聚簇索引：**数据和索引存储到一起，找到索引就获取到了数据

**非聚簇索引：**数据存储和索引分开，叶子节点存储对应的行，需要二次查找才能拿到数据



**SQL 语句主要可以划分为以下 3 个类别。**

- **DDL（Data Definition Languages）语句：**数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。
- **DML（Data Manipulation Language）语句：**数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）
- **DCL（Data Control Language）语句：**数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。

DDL语句会自动提交



SQL语句解析顺序

> `from..` `on..` `join..` `where..` `group by..` `having..` `select distinct..` `order by..` `limit..`

# MySQL

参考[知乎文章]([https://www.zhihu.com/search?type=content&q=MySQL%E4%BC%98%E5%8C%96](https://www.zhihu.com/search?type=content&q=MySQL优化))

参考[博客园文章](https://www.cnblogs.com/annsshadow/p/5037667.html)

![MySQL逻辑架构图](C:\Users\DX\Desktop\正在编辑\images\effce2f028ea18c5aa5b69b3e6859291.jpg)

> MySQL逻辑架构整体分为三层：连接层、服务层、引擎层
>
> 最上层为连接层，诸如：连接处理、授权认证、安全等功能均在这一层处理。
>
> MySQL大多数核心服务均在中间这一层，包括查询解析、分析、**优化**、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。
>
> 最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。

优化无非是要将每一步的流程都做到最优以提高效率，下面让我们看一下当向MySQL发送一个请求的时候，MySQL到底做了些什么。

![](C:\Users\DX\Desktop\正在编辑\images\v2-3158800935bdbd30a57c2263ac8b5eb4_r.jpg)

1. **客户端/服务端通信协议**

   客户端用一个单独的数据包将请求发送给服务器，查询语句过长时需要设置max_allowed_packet参数。

   服务器响应给用户的数据通常会很多，由多个数据包组成，客户端必须完整地接收所有返回结果，所以开发中**尽量保持查询简单且只返回必需的数据**

2. **查询缓存**

   - 在解析一个查询语句前，如果查询缓存是开启的，MySQL会检查是否命中缓存，如果是，检查一次用户权限后直接直接返回缓存中的结果。查询不会被解析和执行。

   - 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果都不会被缓存。
   - 缓存系统会跟踪每个涉及的表，如果这些表发送变化，就要将该表对应的缓存设为失效。如果缓存很大或碎片多，会带来很大的系统消耗。
   - 任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存
   - 如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗
   - **不要轻易打开查询缓存，特别是写密集型应用**

3. **语法解析和预处理**

   MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。

4. **查询优化**

   前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个（并不意味着时间最短）。

5. **查询执行引擎**

   在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。

6. **返回结果**

   查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。

   结果集返回客户端是一个增量且逐步返回的过程。



## MySQL 存储引擎

使用`show engines`可以查看MySQL支持的引擎

InnoDB：MySQL默认；事务优先，适合高并发操作；行锁

MyISAM：性能优先；表锁



#SQL性能分析

使用`explain`分析SQL的执行计划，可以模拟SQL优化器执行SQL语句，从而让开发人员知道自己编写的语句的性能。

**使用方法：**`explain SQL语句`

**参数说明**

- id：序列号，id越大执行优先级越高，相同id从上到下
- select_type：表示对应行是简单还是复杂的查询
  - SIMPLE(简单SELECT，不使用UNION或子查询等)
  - PRIMARY：(查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
  - SUBQUERY：(子查询中的第一个SELECT，结果不依赖于外部查询)
  - DERIVED：衍生查询，用到了子表(派生表的SELECT, FROM子句的子查询)
  -  UNION：(UNION中的第二个或后面的SELECT语句)
  - UNION RESULT：(UNION的结果，union语句中第二个select开始后面所有select)
- table：正在访问哪个表
- type：对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”
  - 性能从好到差 system>const>eq_ref>ref>range>index>all；其中system和const是理想情况，实际达到ref
  - eq_ref：唯一性索引，对每个索引键的查询，返回匹配的唯一（有且只有一个）一行数据
  - ref：非唯一性索引，对于每个索引键的查找，返回匹配的所有行（可能有多个）
  - range：检索给定范围的行，where后是范围查询（where、between、in...）
  - index：查询全部索引的数据，遍历索引树
  - all：没有索引，遍历全表
- possible_keys：可能会使用到的索引
- key：实际用到的索引，如果是null说明没有索引
- key_len：在索引里使用的字节数，用于判断复合索引是否被完全使用
- ref：当前表查找值所参照的字段
  - const：参照值为常量
- rows：实际通过索引查到的数据个数
- Extra：额外信息
  - using filesort：性能消耗大，需要额外的一次排序，待优化
    - 对于单索引，如果查找和排序使用的是同一个字段就不会出现using filesort
    - 对于复合索引，跨列会出现using filesort ，应安装复合索引的顺序使用(index(**a1**,a2,**a3**)，使用where a1,Order by a3即为跨列，a2,a3也为跨列)
    - where 后的索引字段和 order by字段拼起来是复合索引定义的顺序就不会出现using filesort
      - 例如：(where a1..and a4.. order by a2..)不会出现，where中的a4失效后a1和a2还是顺序的
  - using temporary：性能损耗大，用到了临时表，待优化；一般出现在group by语句中
    - 原因：已经有表了，但不适用，需要再生成一张表
    - 根据SQL解析顺序，group by 后的字段是 where 中的字段就不会出现 using temporary
  - using index：索引覆盖，性能提升
    - 原因：只从索引文件中获取，不用读取原文件（不需要回表查询），用到的列都在索引列中就会是using index
  - using where：要查询的字段索引中没有，需要再回表查询，
- Extra

# 性能优化

SQL需要优化的原因：

性能低、执行时间长、等待时间长、SQL语句欠佳（尤其是连接查询）、索引失效、服务器参数设置不合理

SQL语句编写和解析的顺序不同

SQL优化主要在优化索引

**前提：**使用explain执行SQL语句查看一下性能分析

SQL优化是一个概率问题，是一个大部分情况适用的结论

##单表优化

示例表和SQL语句：

| Sno       | Sname | Ssex | Sage | Sdept |
| --------- | ----- | ---- | ---- | ----- |
| 201215121 | 李勇  | 男   | 20   | 1     |
| 201215122 | 刘晨  | 女   | 19   | 1     |
| 201215123 | 王敏  | 女   | 18   | 1     |
| 201215125 | 张立  | 男   | 19   | 3     |

```sql
EXPLAIN SELECT Sname FROM student WHERE Sage IN (18,19) AND Sdept =1 ORDER BY Sage;
```

| type | possible_keys | key  | key_len | ref  | rows | extra                      |
| ---- | ------------- | ---- | ------- | ---- | ---- | -------------------------- |
| ALL  | NULL          | NULL | NULL    | NULL | 4    | using where;using filesort |

1.加索引

给student表加索引`alter table student add index index_nad(Sname,Sage,Sdept);`

将要查询的列Sname加入到索引可以避免再回表查询。

再使用explain分析一下：

| type  | possible_keys | key       | key_len | ref  | rows | extra                      |
| ----- | ------------- | --------- | ------- | ---- | ---- | -------------------------- |
| index | NULL          | index_nad | 51      | NULL | 4    | using where;index;filesort |

2.根据SQL实际解析顺序，调整索引的顺序。

由于SQL解析顺序是先解析where后解析select，故Sage和Sdept应该在前，Sname应该在后，以避免跨列。

删除原来索引，新建索引`alter table student add index index_adn(Sage,Sdept,Sname);`再分析

| type  | possible_keys | key       | key_len | ref  | rows | extra             |
| ----- | ------------- | --------- | ------- | ---- | ---- | ----------------- |
| range | index_adn     | index_adn | 2       | NULL | 3    | using where;index |

结论：

- 最佳左前缀，保持索引的定义和使用的顺序一致性（还要考虑到个字段索引可能失效后产生的索引跨列问题）
- 索引需要逐步优化

## 多表优化

索引往哪里加？两个原则：

- 小表驱动大表：

  `select ... where smallTab.x = bigTab.y`将数据量小的表放左边。

  两层循环外层少内层多的情况下比外层多内层少的情况性能更高

- 索引建立在经常使用的字段上

- 一般左连接给左表加索引，右连接给右表加索引。

## 避免索引失效的原则

MySQL5.5

1. 复合索引，不要跨列或无序使用（最佳左前缀）
2. 复合索引，尽量使用全索引匹配（可以的话，复合索引尽量全用上）
3. 不要在索引上进行任何操作（计算、函数、类型转换），否则索引会失效。
4. 复合索引左边失效，右边全部失效
5. 复合索引不能使用不等`!=`或者`is (not) null`，否则自身及右边全部失效。     
6. like尽量以常量开头，否则索引会失效。（如果必须要以`%`开头，可以使用索引覆盖挽救一部分）
7. 尽量不要使用类型转换，否则索引会失效。
8. 尽量不要使用`or`否则索引失效
9. 其他优化方法
   1. 如果主查询的数据集大，则使用`IN`
   2. 如果子查询的数据集大，则使用`EXISTS`
   3. `IN`和`Exists`的区别：`EXISTS`先查主查询，将其的结果拿到子查询中校验，看是否有主查询中的列；而`IN`先查子查询，再看其中有没有和主查询匹配的数据；（小表驱动大表的思想）

## 开启慢查询日志

MySQL 的一种日志记录，用于记录MySQL中响应时间超过阈值的SQL语句（long_query_time，默认为10秒）

慢查询日志默认是关闭的，查看是否开启了慢查询日志`show variable like '%slow_query_log'`

临时开启：`set global slow_query_log = 1`服务重启后自动关闭

永久开启：在etc/mysql.cnf的[mysqld]中追加

```properties
slow_query_log=1
slow_query_log_file=/var/lib/mysql/localhost-slow.log
##永久设置超时阈值
long_query_time=int_seconds`
```

更改慢查询阈值：

- 临时设置：`set global long_query_time=int_seconds`重新登录后生效
- 永久设置：见上文配置文件

通过日志，查看具体的慢SQL

`cat /var/lib/mysql/localhost-slow.log`

使用`mysqldumpslow`快速定位慢SQL











没有关于优化的绝对真理，应该在实际的业务场景下通过测试来验证关于执行计划以及响应时间的假设。

几个技巧

1. 通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。
2. 对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。
3. UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。
4. 通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。
5. TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。
6. 大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。
7. schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。
8. 大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久
9. 表关联查询时务必遵循 **小表驱动大表** 原则；
10. 使用查询语句 `where` 条件时，不允许出现 **函数**，否则索引会失效；
11. 使用单表查询时，相同字段尽量不要用 `OR`，因为可能导致索引失效，比如：`SELECT * FROM table WHERE name = '手机' OR name = '电脑'`，可以使用 `UNION` 替代；
12. `LIKE` 语句不允许使用 `%` 开头，否则索引会失效；
13. 组合索引一定要遵循 **从左到右** 原则，否则索引会失效；比如：`SELECT * FROM table WHERE name = '张三' AND age = 18`，那么该组合索引必须是 `name,age` 形式；
14. 索引不宜过多，根据实际情况决定，尽量不要超过 10 个；

## 创建高性能索引

索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。

`EXPLAIN` 显示了 MySQL 如何使用索引来处理 `SELECT` 语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。

##Scheme设计与数据类型优化

选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。

## 存储引擎

数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作，属于内模式。

对于MySQL 5.5及更高版本，默认的存储引擎是InnoDB。在5.5版本之前，MySQL的默认存储引擎是MyISAM

MySQL 中，针对具体的要求，可以对每一个表使用不同的存储引擎。

使用`show engines`查看系统支持的存储引擎类型

| 功能         | MyISAM | InnoDB |
| ------------ | ------ | ------ |
| 存储限制     | 256TB  | 64TB   |
| 支持事务     | No     | Yes    |
| 支持全文索引 | Yes    | No     |
| 支持树索引   | Yes    | Yes    |
| 支持哈希索引 | No     | No     |
| 支持数据缓存 | No     | Yes    |
| 支持外键     | No     | Yes    |

### InnoDB存储引擎

如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。

InnoDB必须要有主键，推荐使用整型自增主键。

####独立表空间

每个表的数据和索引都会存储在各个独立的表空间中

####共享表空间

某一个数据库所有的表数据，索引文件全部都放在一个文件中

### MyISAM存储引擎

该存储引擎管理非事务性表，提供高速存储和检索，支持全文搜索。如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。

## MySQL优化

MySQL优化主要分为以下四大方面：

- 设计：存储引擎，字段类型，范式与逆范式
- 功能：索引，缓存，分区分表
- 架构：主从复制，读写分离，负载均衡
- SQL语句：测试、经验

# MySQL索引

索引是帮助MySQL高效获取数据的排好序的数据结构

如果一个字段是primary key，则该字段默认就是**主键索引**

**索引的弊端：**

- 索引本身会占用内存空间
- 少量数据情况不适用；频繁更新的字段不适用；很少使用的字段不适用
- 要维护索引表

**索引的好处：**

- 提高查询的效率（降低IO使用率）
- 降低CPU使用率（索引已经排好序）

**索引的分类：**

单值索引：单列构成的索引，一个表可以有多个单值索引

唯一索引：索引列的值必须唯一，但允许有空值

主键索引：索引列的值必须唯一，不允许有空值

复合索引：多个列构成的索引（复合索引使用的顺序最好按照定义的顺序）

##创建索引

###使用CREATE创建索引

创建索引：`CREATE [索引类型] [索引名] ON [表(字段)]`

创建复合索引：`CREATE INDEX index_name ON [表(字段1,字段2,...)]`

索引类型包括

- 唯一索引使用`UNIQUE INDEX`
- 唯一索引和复合索引使用`INDEX`

### 使用ALTER创建索引

`ALTER table tableName ADD INDEX indexName(columnName)`

具体方法同上

###删除索引

`DROP INDEX index_name ON table_name`

### 查询索引

`SHOW INDEX FROM table_name`







索引数据结构：

- 二叉树
- 红黑树
- Hash表
- B-Tree
- B+Tree

MySQL索引类型：

- 单列索引：一个索引
- 组合索引



聚集(簇)索引：**索引文件和数据文件是存储在一起的

**非聚集(簇)索引：**索引文件和数据文件是分离的

**联合索引：**

## InnoDB索引实现

- 表数据文件本身就是按B+Tree组织的一个索引文件
- 聚集索引的叶节点包含了完整的数据记录
- 

# 分析海量数据

- 使用profiles

`profiles`会记录打开profile之后的所有SQL语句所花费的时间，`profiles`默认是关闭的。

1. 查看profiling相关：`show variables like '%profiling%'`
2. 开启：`set profiling = on`
3. 查看：`show profiles`

缺点：不够精确，查看的是SQL处理过程总的时间

- 精确分析使用SQL诊断

`show profile all for query ID`此处ID为使用`show profiles`查询到的SQL语句的ID

通过此方法可以查看每一步处理所用的时间

- 全局查询日志

会在开启之后记录全部SQL语句，会影响性能所以仅在调优和开发中使用

查看状态：`show variables like '%general_log%'`

开启全局日志：`set global general_log = 1` 

将全部文件记录在表/文件中`set global log_output='table/file'`

开启之后，所有的SQL都会被记录到mysql.general_log表中



# 锁机制

锁类型：

读锁：共享锁

写锁：互斥锁

锁操作范围：表锁和行锁

研究锁需要在MySQL中禁用自动提交。

##表锁

一次性对一张表加锁。读写互斥。

MyISAM在执行查询语句前会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁。

- 优点：开销小，加锁快，无死锁
- 缺点：锁的范围大，并发性低，容易发生锁冲突

加读/写锁：`lock table tablename read/write`；

释放锁：`unlock tables`

查看哪些表加了锁：`show open tables` 1代表被加了锁

分析表锁定的严重程度：`show status like table%`

- `Table_locks_waited`：数值越大，竞争越大。
- `Table_locks_immediate`：

如果某一个会话对A表加了读锁，则该会话可以对A表进行读操作，不能进行写操作；且该会话不能对其他表进行读、写操作；即当前会话智能对A表进行读操作，其他会话可以读A表，写A表的时候会等待获取锁，可读写其他表

如果某一个会话对A表加了写锁，该会话可以对A表进行任何操作，但是不能操作其他表。其他会话只能等锁释放后才能进行增删改查

##行锁

一次性对一行数据加锁,，InnoDB默认

- 优点：锁的范围小，不易发生锁冲突，并发度高。
- 缺点：开销大

注意事项：

1. 如果没有索引或索引失效，则行锁会转为表锁。
2. 如果有where，加锁的范围是where后的全部范围（where x>1 and x<10，即使列中没有x=7的行，改行也会被加锁，成为间隙锁。释放锁之前无法insert x=7)

行锁分析：

show status like %innodb_row_lock%

- `innodb_row_lock_current_waits`：当前正在等待锁的数量
- `Innodb_row_lock_time`：等待总时长。从系统启动到现在一共等待的时间

- `Innodb_row_lock_time_avg`：平均等待时长。
- `Innodb_row_lock_time_max`：最大一次等待时长。
- `Innodb_row_lock_waits`：一共等待的次数。

# 事务

## 事务的四种特性ACID

1. 原子性 （atomicity）:强调事务的不可分割.
2. 一致性 （consistency）:事务的执行的前后数据的完整性保持一致.
3. 隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰
4. 持久性（durability） :事务一旦结束,数据就持久到数据库

## 四种隔离级别

**READ UNCOMMITTED (未提交读)**

事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，会产生**脏读**

**READ COMMITTED (提交读)**

一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的，这个级别也叫**不可重复读**

**REPEATABLE READ (可重复读)**

**默认的隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。

**Serializable（可串行化）**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。





幻读：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行