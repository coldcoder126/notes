# 微服务架构下的事务管理

## 两阶段提交

两阶段提交又称**2PC（two-phase commit protocol**）,2pc是一个非常经典的**强一致、中心化的原子提交协议**。这里所说的中心化是指协议中有两类节点：一个是中心化**协调者节点（coordinator）**和**N个参与者节点（partcipant）**。



发起者向分布式事务协调者发送请求，分布式事务开始

第一阶段：请求/表决阶段：协调者向参与事务的各方发送事务预处理请求(prepare)，参与者收到请求后会开始执行数据库本地事务，执行完成后不会马上提交，而是向协调者发送反馈“我可以处理`Vote Commit`”或不能处理`Vote_Abort`。若协调者收到所有参与者都可以处理，则进入第二阶段；若收到一个不能处理，协调者会要求所有的参与者回滚。

第二阶段：提交/执行阶段：协调者向所有参与者发送全局提交确认通知`global_commit`，要求参与者将数据提交，此时参与者会将自身本地数据库事务提交，并最终将提交结果回复`ack`给协调者。协调者将分布式事务处理结果返回给发起者。



**缺点分析：**

- **性能问题**。从流程上我们可以看得出，其最大缺点就在于它的执行过程中间，节点都处于阻塞状态。各个操作数据库的节点此时都占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大。

- **协调者单点故障问题**。事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚的通知，从而导致参与者节点始终处于事务无法完成的中间状态。

- **丢失消息导致的数据不一致问题。**在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题。

## 三阶段提交

三阶段提交又称**3PC**，其在两阶段提交的基础上**增加了CanCommit阶段**，并**引入了超时机制**。一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。



## TCC

TCC（**Try-Confirm-Cancel**）又称补偿事务。其核心思想是："针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）"。它分为三个操作：

- Try阶段：主要是对业务系统做检测及资源预留。

- Confirm阶段：确认执行业务操作。

- Cancel阶段：取消执行业务操作。

TCC事务的处理流程与2PC两阶段提交类似，不过2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让**应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能**。

而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口还必须实现幂等。





##Saga

传统的解决方案是使用基于两阶段提交的分布式事务管理机制，但对于微服务来说并不是一个好的选择，微服务使用Saga

> Saga使用异步消息来协调一系列本地事务，从而维护多个服务之间的数据一致性。

Sage中有一系列的本地事务，Saga的第一个事务由创建订单的外部请求启动，后面的事务由前一个完成触发。

Saga之间缺乏隔离

传统的ACID事务的一个重要特性是：如果业务逻辑检测到违反业务规则，可以回滚目前所做的所有更改。而Saga每个步骤都已提交到数据库